from __future__ import annotations

import json
import os
from pathlib import Path
from types import SimpleNamespace
from typing import Optional, Sequence

import typer

from latexify.ingestion import ingest_pdf as ingest_pdf_cli
from latexify.pipeline import aggregator as aggregator_cli
from latexify.pipeline import judge_model as judge_cli
from latexify.pipeline import planner_scaffold
from latexify.pipeline import qa_validator
from latexify.pipeline import tex_assembler as assembler_cli

app = typer.Typer(help="Unified entry point for LaTeXify pipelines.", add_completion=False)


def _forward(func, args: Sequence[str]) -> None:
    exit_code = func(list(args) if args else None)
    raise typer.Exit(exit_code)


@app.command("ingest")
def ingest(ctx: typer.Context) -> None:
    """Proxy to latexify-ingest-pdf (pass-through arguments after `--`)."""
    _forward(ingest_pdf_cli.main, ctx.args)


@app.command("judge")
def judge(ctx: typer.Context) -> None:
    """Proxy to latexify-judgecouncil."""
    _forward(judge_cli.main, ctx.args)


@app.command("assemble")
def assemble(ctx: typer.Context) -> None:
    """Proxy to latexify-tex-assembler."""
    _forward(assembler_cli.main, ctx.args)


def _auto_plan_from_consensus(
    consensus_path: Path,
    *,
    doc_class: str,
    title: str,
    author: str,
    course: str,
) -> dict:
    consensus = planner_scaffold._load_block_consensus(consensus_path)
    if not consensus:
        raise typer.BadParameter(f"No consensus blocks found at {consensus_path}; cannot build plan.")
    questions = list(consensus.keys())
    plan = planner_scaffold._emit_plan(
        doc_class,
        title=title,
        author=author,
        course=course,
        questions=questions,
        layout_blocks=None,
        assets=planner_scaffold.AssetLookup(),
        block_consensus=consensus,
    )
    plan.setdefault("content_flags", {})
    plan.setdefault("doc_class_hint", {"candidate": doc_class})
    planner_scaffold.validate_plan(plan)
    return plan


def _write_json(path: Path, payload: dict) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(json.dumps(payload, indent=2), encoding="utf-8")


@app.command("run")
def run_pipeline(
    pdf: Path = typer.Argument(..., exists=True, file_okay=True, dir_okay=False, readable=True, resolve_path=True, help="Input PDF"),
    out_dir: Path = typer.Option(Path("build"), "--out-dir", "-o", resolve_path=True, help="Base directory for artifacts"),
    run_name: Optional[str] = typer.Option(None, "--run-name", help="Override run folder name (defaults to PDF stem)"),
    doc_class: str = typer.Option("lix_textbook", "--doc-class", help="Default document class for the auto plan"),
    title: Optional[str] = typer.Option(None, "--title", help="Document title"),
    author: str = typer.Option("Generated by LaTeXify", "--author", help="Frontmatter author"),
    course: str = typer.Option("", "--course", help="Optional course/program label"),
    skip_qa: bool = typer.Option(False, "--skip-qa", help="Skip QA validator before aggregation"),
    skip_compile: bool = typer.Option(False, "--skip-compile", help="Only assemble main.tex (no latexmk)"),
    max_pages: Optional[int] = typer.Option(None, "--max-pages", help="Limit ingestion to first N pages"),
    internvl_endpoint: Optional[str] = typer.Option(None, "--internvl-endpoint", help="OpenAI-compatible endpoint for InternVL"),
    florence_endpoint: Optional[str] = typer.Option(None, "--florence-endpoint", help="OpenAI-compatible endpoint for Florence-2"),
    allow_fallback: bool = typer.Option(False, "--allow-fallback", help="Permit OCR fallback text when endpoints are missing"),
):
    """Run ingestion → judge → plan → synth → (optional) QA → aggregation in one command."""

    run_slug = run_name or pdf.stem
    run_root = (out_dir / "runs" / run_slug).resolve()
    ingest_root = run_root / "ingest"
    build_root = run_root / "build"
    assets_dir = build_root / "assets"
    snippets_dir = build_root / "snippets"
    plan_path = run_root / "plan.auto.json"

    internvl_endpoint = internvl_endpoint or os.environ.get("LATEXIFY_INTERNVL_ENDPOINT")
    florence_endpoint = florence_endpoint or os.environ.get("LATEXIFY_FLORENCE_ENDPOINT")
    if not allow_fallback:
        missing = []
        if not internvl_endpoint:
            missing.append("InternVL (set --internvl-endpoint or LATEXIFY_INTERNVL_ENDPOINT)")
        if not florence_endpoint:
            missing.append("Florence-2 (set --florence-endpoint or LATEXIFY_FLORENCE_ENDPOINT)")
        if missing:
            raise typer.BadParameter("Missing OCR endpoints: " + ", ".join(missing))

    typer.echo(f"[run] Ingesting {pdf} → {ingest_root}")
    ingest_root.mkdir(parents=True, exist_ok=True)
    ingest_pdf_cli.ingest_pdf(
        pdf,
        ingest_root,
        assets_dir=assets_dir,
        max_pages=max_pages,
        internvl_endpoint=internvl_endpoint,
        florence_endpoint=florence_endpoint,
    )

    typer.echo("[run] Consolidating OCR via judge model")
    blocks_path = judge_cli.run_judge(ingest_root)

    plan_title = title or pdf.stem
    typer.echo(f"[run] Building auto plan ({plan_title})")
    plan_payload = _auto_plan_from_consensus(
        blocks_path,
        doc_class=doc_class,
        title=plan_title,
        author=author,
        course=course,
    )
    _write_json(plan_path, plan_payload)

    typer.echo(f"[run] Synthesizing snippets → {snippets_dir}")
    args = SimpleNamespace(
        plan=plan_path,
        consensus=blocks_path,
        layout_plan=None,
        snippets_dir=snippets_dir,
        golden_dir=None,
        model_path=None,
        n_ctx=8192,
        temperature=0.2,
        max_tokens=600,
        aggregate=False,
        build_dir=None,
        verbose=False,
    )
    assembler_cli.assemble(args)

    if not skip_qa:
        typer.echo("[run] Running QA validator")
        report_path = qa_validator.run_preflight(
            plan_path,
            snippets_dir,
            build_dir=build_root,
            attempt_compile=False,
        )
        typer.echo(f"[run] QA report: {report_path}")

    typer.echo("[run] Aggregating & compiling")
    agg_result = aggregator_cli.run_aggregator(
        plan_path,
        snippets_dir,
        build_root,
        no_compile=skip_compile,
        simulate=False,
        assets_dir=str(assets_dir) if assets_dir.exists() else None,
        engine_override=None,
        verbose=False,
    )
    main_tex = Path(agg_result["main_tex"]).resolve()
    typer.echo(f"[run] Completed build → {main_tex}")
    if not skip_compile:
        typer.echo(f"[run] PDF available at {main_tex.with_suffix('.pdf')}")


def run() -> None:
    app()


if __name__ == "__main__":
    run()
