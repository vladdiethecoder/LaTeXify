from __future__ import annotations

import argparse
import json
import re
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Sequence, Tuple

from pydantic import ValidationError

from latexify.assembly.snippets import body_snippet, figure_snippet, math_snippet
from latexify.assembly.utils import escape_tex, inject_packages, _unique
from latexify.models.schemas import ConsensusBlockSchema, LayoutBlueprintSchema, PlanSchema

from .synth_shared import capabilities_from_text, slugify
from ..utils.logging import configure_logging, log_info

TABLE_DIVIDER_RX = re.compile(r"^[\s\-\+=|:._]+$")
NUMERIC_RX = re.compile(r"^[+-]?\d+(?:[.,]\d+)?(?:%|/\d+)?$")

try:  # optional llama backend for local coder models
    from .model_backends import LlamaCppBackend, LlamaCppConfig
except Exception:  # pragma: no cover - llama backend might be unavailable
    LlamaCppBackend = None  # type: ignore
    LlamaCppConfig = None  # type: ignore

@dataclass
class PlanTask:
    task_id: str
    title: str
    kind: str
    content_type: str
    block_id: Optional[str]
    order: int
    asset_path: Optional[str]
    notes: Dict[str, Any]


@dataclass
class ConsensusBlock:
    block_id: str
    text: str
    block_type: str
    page_index: int
    flagged: bool
    ocr_outputs: Dict[str, str]
    assets: List[str]


class LocalLLM:
    def __init__(self, model_path: Path, *, n_ctx: int = 8192, temperature: float = 0.2, max_tokens: int = 600):
        if LlamaCppBackend is None or LlamaCppConfig is None:  # pragma: no cover - runtime guard
            raise RuntimeError("llama-cpp-python is not installed; cannot use --model-path")
        cfg = LlamaCppConfig(model_path=model_path, n_ctx=n_ctx, n_batch=512, seed=1337)
        self.backend = LlamaCppBackend(cfg)
        self.temperature = temperature
        self.max_tokens = max_tokens

    def generate(self, prompt: str) -> str:
        return self.backend.generate(
            prompt,
            max_tokens=self.max_tokens,
            temperature=self.temperature,
            top_p=0.9,
            top_k=40,
            repeat_penalty=1.05,
            stop=("```", "\n\n#", "\n\nTask"),
        ).strip()


class TexAssembler:
    def __init__(
        self,
        *,
        llm: Optional[LocalLLM],
        blueprint: LayoutBlueprintSchema | Dict[str, Any] | None = None,
    ) -> None:
        self.llm = llm
        self.blueprint = blueprint or {}
        self._layout_plan = self._resolve_layout_plan(self.blueprint)

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------
    def preamble_snippet(self, doc_class: str, packages: Sequence[str]) -> str:
        blueprint_note = self._blueprint_summary()
        if self.llm:
            prompt = self._preamble_prompt(doc_class, blueprint_note)
            generated = self.llm.generate(prompt)
            cleaned = self._extract_latex(generated)
            if cleaned:
                return inject_packages(cleaned, packages)
        return self._fallback_preamble(doc_class, blueprint_note, packages)

    def title_snippet(self, frontmatter: Dict[str, Any]) -> str:
        title = escape_tex(frontmatter.get("title", "Untitled Document"))
        author = escape_tex(frontmatter.get("author", "Generated by LaTeXify"))
        course = frontmatter.get("course")
        if course:
            author = f"{author} \\textit{{({escape_tex(course)})}}"
        date = frontmatter.get("date", r"\today")
        return "\n".join([
            f"\\title{{{title}}}",
            f"\\author{{{author}}}",
            f"\\date{{{date}}}",
            r"\maketitle",
            "",
        ])

    def section_snippet(self, task: PlanTask, block: Optional[ConsensusBlock]) -> str:
        context = self._build_section_context(task, block)
        layout_meta = self._layout_section_meta(task)
        section_head = self._section_command(task, layout_meta.get("level"))
        if self.llm:
            prompt = self._section_prompt(task, block, context)
            completion = self.llm.generate(prompt)
            cleaned = self._extract_latex(completion)
            if cleaned:
                return cleaned if cleaned.endswith("\n") else cleaned + "\n"
        return self._render_fallback_section(task, block, context, section_head, layout_meta.get("multicolumn", False))

    # ------------------------------------------------------------------
    # Prompt helpers
    # ------------------------------------------------------------------
    def _preamble_prompt(self, doc_class: str, blueprint_note: str) -> str:
        guidelines = blueprint_note or "Follow best practices for academic textbooks."
        return (
            r"You are a meticulous LaTeX engineer. Emit ONLY a preamble with \documentclass and required packages.\n"
            "Constraints:\n"
            f"- Document class: {doc_class}.\n"
            "- Include packages only if justified.\n"
            "- End with \\begin{document}.\n"
            f"Layout guidance: {guidelines}\n"
        )

    def _section_prompt(self, task: PlanTask, block: Optional[ConsensusBlock], context: Dict[str, str]) -> str:
        title = task.title or task.task_id
        blueprint_detail = self._blueprint_detail_for(title)
        block_text = context.get("source_text", "")
        hints = context.get("hints", "")
        return (
            "You are an expert LaTeX synthesizer. Convert the provided OCR text into polished LaTeX.\n"
            "Rules:\n"
            "- Output ONLY LaTeX for the section body (no preamble).\n"
            "- Use semantic structures (sections, figure, table, equation).\n"
            "- Prefer amsmath + booktabs conventions.\n"
            f"Section: {title}. Kind={task.kind} ContentType={task.content_type}.\n"
            f"Blueprint hints: {blueprint_detail}.\n"
            f"Layout guidance: {hints}.\n"
            "OCR snippet:\n" + block_text + "\nEnd of text."
        )

    # ------------------------------------------------------------------
    # Fallback renderers
    # ------------------------------------------------------------------
    def _fallback_preamble(self, doc_class: str, blueprint_note: str, packages: Sequence[str]) -> str:
        defaults = [
            "\\usepackage{microtype}",
            "\\usepackage{geometry}",
            "\\usepackage{hyperref}",
        ]
        combined_packages = _unique(defaults + list(packages))
        lines = [f"\\documentclass{{{doc_class or 'lix_textbook'}}}"]
        if blueprint_note:
            lines.append(f"% Layout: {blueprint_note}")
        lines.append(r"\geometry{margin=1in}")
        lines.append(r"\hypersetup{hidelinks}")
        lines.append(r"\begin{document}")
        base = "\n".join(lines) + "\n"
        return inject_packages(base, combined_packages)

    def _render_fallback_section(
        self,
        task: PlanTask,
        block: Optional[ConsensusBlock],
        context: Dict[str, str],
        section_head: str,
        multicolumn: bool,
    ) -> str:
        title = task.title or task.task_id
        label = slugify(task.task_id or title)
        block_kind = (block.block_type if block else task.kind or task.content_type or "").lower() if (block or task.kind or task.content_type) else ""
        if block and block_kind.startswith("figure"):
            asset_path = task.asset_path
            if not asset_path and block.assets:
                asset_path = block.assets[0]
            return figure_snippet(asset_path or "assets/figure-placeholder.pdf", title, label)
        if block and "table" in block_kind:
            raw_text = context.get("source_text", block.text)
            return self._render_table_from_text(raw_text, title, label)
        if block and "math" in block_kind:
            return math_snippet(block.text, title, label)
        body_source = context.get("source_text", block.text if block else "")
        return body_snippet(section_head, title, label, body_source, multicolumn=multicolumn)

    def _render_table_from_text(self, raw_text: str | None, title: str, label: str) -> str:
        header, body, alignment = _parse_table_from_text(raw_text or "")
        if not header:
            return "% TODO: add table content\n"
        fmt = alignment or ("l" * len(header)) or "l"
        lines = [
            "\\begin{table}[ht]",
            "  \\centering",
            f"  \\caption{{{escape_tex(title)}}}",
            f"  \\label{{tab:{label}}}",
            f"  \\begin{{tabular}}{{{fmt}}}",
            "    \\toprule",
            "    " + " & ".join(escape_tex(cell) for cell in header) + r" \\",
            "    \\midrule",
        ]
        for row in body:
            escaped = [escape_tex(cell) for cell in row]
            lines.append("    " + " & ".join(escaped) + r" \\")
        lines.extend([
            "    \\bottomrule",
            "  \\end{tabular}",
            "\\end{table}",
            "",
        ])
        return "\n".join(lines)

    # ------------------------------------------------------------------
    # Utility helpers
    # ------------------------------------------------------------------
    def _blueprint_summary(self) -> str:
        plan = self._layout_plan if isinstance(self._layout_plan, dict) else {}
        layout = plan.get("page_layout") if isinstance(plan.get("page_layout"), dict) else {}
        columns = layout.get("columns") if isinstance(layout, dict) else None
        title_area = layout.get("title_area") if isinstance(layout, dict) else None
        if columns or title_area:
            return f"columns={columns or 'single'}, title_area={title_area or 'top'}"
        return ""

    def _blueprint_detail_for(self, title: str) -> str:
        plan = self._layout_plan if isinstance(self._layout_plan, dict) else {}
        sections = plan.get("sections")
        if not isinstance(sections, list):
            return ""
        for section in sections:
            if not isinstance(section, dict):
                continue
            if section.get("title") and section.get("title").lower() in title.lower():
                return section.get("layout", "")
        return ""

    def _section_command(self, task: PlanTask, override: Optional[str] = None) -> str:
        if override:
            level = override.lower()
            if level.startswith("sub"):
                return "\\subsection"
            if "chapter" in level:
                return "\\chapter"
            if "appendix" in level:
                return "\\section"
        kind = (task.kind or task.content_type or "body").lower()
        if "subsection" in kind:
            return "\\subsection"
        if "chapter" in kind:
            return "\\chapter"
        if "appendix" in kind:
            return "\\section"
        return "\\section"

    def _build_section_context(self, task: PlanTask, block: Optional[ConsensusBlock]) -> Dict[str, str]:
        ctx: Dict[str, str] = {}
        if block:
            ctx["source_text"] = block.text or block.ocr_outputs.get(task.notes.get("backend", ""), "") if task.notes else block.text
            ctx["hints"] = f"block_type={block.block_type}, page_index={block.page_index}"
        else:
            ctx["source_text"] = task.notes.get("placeholder", "") if task.notes else ""
            ctx["hints"] = "no block data"
        return ctx

    def _layout_section_meta(self, task: PlanTask) -> Dict[str, Any]:
        plan = self._layout_plan if isinstance(self._layout_plan, dict) else {}
        meta: Dict[str, Any] = {"level": None, "multicolumn": False}
        if not plan:
            return meta
        section_entry = self._match_layout_entry(task, plan.get("sections"))
        if section_entry is None:
            section_entry = self._match_layout_entry(task, plan.get("chunks"))
        if section_entry:
            layout_text = str(section_entry.get("layout") or "").lower()
            notes = " ".join(section_entry.get("notes", [])) if isinstance(section_entry.get("notes"), list) else ""
            if _looks_multicolumn(f"{layout_text} {notes}"):
                meta["multicolumn"] = True
            kind = str(section_entry.get("kind") or "").lower()
            if "subsection" in kind:
                meta["level"] = "subsection"
            elif "appendix" in kind:
                meta["level"] = "appendix"
            elif "chapter" in kind:
                meta["level"] = "chapter"
        if not meta["multicolumn"]:
            columns_desc = str(plan.get("page_layout", {}).get("columns", "")).lower()
            if _looks_multicolumn(columns_desc):
                meta["multicolumn"] = True
        return meta

    def _match_layout_entry(self, task: PlanTask, entries: Any) -> Optional[Dict[str, Any]]:
        if not isinstance(entries, list):
            return None
        task_title = (task.title or "").lower()
        task_id = (task.task_id or "").lower()
        for entry in entries:
            if not isinstance(entry, dict):
                continue
            entry_title = str(entry.get("title") or "").lower()
            entry_id = str(entry.get("id") or "").lower()
            if entry_title and task_title and (entry_title in task_title or task_title in entry_title):
                return entry
            if entry_id and task_id and entry_id == task_id:
                return entry
        return None

    @property
    def layout_flags(self) -> Dict[str, bool]:
        plan = self._layout_plan if isinstance(self._layout_plan, dict) else {}
        flags = plan.get("content_flags")
        return flags if isinstance(flags, dict) else {}

    def _resolve_layout_plan(self, blueprint: LayoutBlueprintSchema | Dict[str, Any] | None) -> Dict[str, Any]:
        if isinstance(blueprint, LayoutBlueprintSchema):
            return blueprint.plan or {}
        if isinstance(blueprint, dict):
            plan = blueprint.get("plan")
            if isinstance(plan, dict):
                return plan
            return blueprint
        return {}


def _looks_multicolumn(value: str) -> bool:
    lowered = (value or "").lower()
    return any(token in lowered for token in ("two-column", "two column", "double column", "multicol", "multi-column"))


def _parse_table_from_text(raw_text: str) -> Tuple[List[str], List[List[str]], str]:
    lines = [line.strip() for line in (raw_text or "").splitlines() if line.strip()]
    lines = [line for line in lines if not TABLE_DIVIDER_RX.match(line)]
    if not lines:
        return [], [], ""
    pipe_votes = sum("|" in line for line in lines)
    use_pipes = pipe_votes >= max(1, len(lines) // 2)
    rows: List[List[str]] = []
    max_width = 0
    carry = ""
    for line in lines:
        cells = _split_table_line(line, use_pipes)
        if cells is None:
            carry = f"{carry} {line.strip()}".strip() if carry else line.strip()
            continue
        if carry:
            if cells:
                cells[0] = f"{carry} {cells[0]}".strip()
            else:
                cells = [carry]
            carry = ""
        rows.append(cells)
        max_width = max(max_width, len(cells))
    if not rows:
        return [], [], ""
    if carry and rows:
        rows[-1][0] = f"{rows[-1][0]} {carry}".strip()
    normalized = [_pad_row(row, max_width) for row in rows]
    header = normalized[0]
    body = normalized[1:] or [["" for _ in range(max_width)]]
    alignment = _infer_alignment(normalized)
    return header, body, alignment


def _split_table_line(line: str, use_pipes: bool) -> List[str] | None:
    if use_pipes:
        if "|" not in line:
            return None
        parts = [part.strip() for part in line.strip("|").split("|")]
        cells = [part for part in parts if part]
        return cells or None
    parts = [part.strip() for part in re.split(r"\s{2,}", line) if part.strip()]
    if len(parts) <= 1:
        return None
    return parts


def _pad_row(row: List[str], width: int) -> List[str]:
    if len(row) >= width:
        return list(row)
    padded = list(row)
    padded.extend(["" for _ in range(width - len(row))])
    return padded


def _infer_alignment(rows: Sequence[Sequence[str]]) -> str:
    if not rows:
        return ""
    width = len(rows[0])
    result: List[str] = []
    for col_idx in range(width):
        column = [row[col_idx] for row in rows if col_idx < len(row)]
        result.append(_infer_column_alignment(column))
    return "".join(result)


def _infer_column_alignment(values: Sequence[str]) -> str:
    tokens = [value.strip() for value in values if value and value.strip()]
    if not tokens:
        return "l"
    payload = tokens[1:] or tokens
    numeric_hits = sum(1 for token in payload if _looks_numeric(token))
    if numeric_hits and numeric_hits / len(payload) >= 0.6:
        return "r"
    short_hits = sum(1 for token in payload if _looks_short_token(token))
    if short_hits and short_hits / len(payload) >= 0.7:
        return "c"
    return "l"


def _looks_numeric(value: str) -> bool:
    cleaned = value.replace(",", "").replace("%", "").replace("âˆ’", "-").strip()
    if not cleaned:
        return False
    return bool(NUMERIC_RX.match(cleaned))


def _looks_short_token(value: str) -> bool:
    token = value.strip()
    if not token:
        return False
    if len(token) <= 3:
        return True
    return token.isalpha() and token.isupper() and len(token) <= 5

    def _extract_latex(self, completion: str) -> str:
        text = completion.strip()
        if not text:
            return ""
        fence_idx = text.find("\n```")
        if fence_idx != -1:
            text = text[:fence_idx].strip()
        return text

    # ------------------------------------------------------------------
    # Parsing helpers
    # ------------------------------------------------------------------


def determine_packages(flags: Dict[str, bool], snippets: Iterable[str]) -> List[str]:
    packages: List[str] = []
    if flags.get("has_math"):
        packages.extend(["\\usepackage{amsmath}", "\\usepackage{amssymb}"])
    if flags.get("has_tables"):
        packages.extend(["\\usepackage{booktabs}", "\\usepackage{caption}"])
    if flags.get("has_figures"):
        packages.append("\\usepackage{graphicx}")
    if flags.get("has_code"):
        packages.append("\\usepackage{listings}")
    if flags.get("has_chem"):
        packages.append("\\usepackage[version=4]{mhchem}")
    if flags.get("has_math") or flags.get("has_chem"):
        packages.append("\\usepackage{siunitx}")
    if flags.get("two_column"):
        packages.append("\\usepackage{multicol}")
    text_blob = "\n".join(snippets).lower()
    if "\\includegraphics" in text_blob and "\\usepackage{graphicx}" not in packages:
        packages.append("\\usepackage{graphicx}")
    if "\\ce{" in text_blob and not any("mhchem" in pkg for pkg in packages):
        packages.append("\\usepackage[version=4]{mhchem}")
    return _unique(packages)


def _load_golden_snippet(golden_dir: Optional[Path], task_id: str) -> Optional[str]:
    if not golden_dir or not Path(golden_dir).exists():
        return None
    candidate = Path(golden_dir) / f"{task_id}.tex"
    if candidate.exists():
        return candidate.read_text(encoding="utf-8")
    return None


def load_plan(path: Path) -> PlanSchema:
    try:
        payload = json.loads(path.read_text(encoding="utf-8"))
    except json.JSONDecodeError as exc:  # pragma: no cover - defensive guard
        raise ValueError(f"Plan file {path} is not valid JSON") from exc
    try:
        return PlanSchema.parse_obj(payload)
    except ValidationError as exc:
        raise ValueError(f"Plan file {path} failed validation: {exc}") from exc


def parse_tasks(plan: PlanSchema) -> List[PlanTask]:
    tasks: List[PlanTask] = []
    for task_schema in plan.tasks:
        task_id = task_schema.id
        raw_extra = {
            key: value
            for key, value in task_schema.__dict__.items()
            if not key.startswith("_") and key not in task_schema.__fields__
        }
        notes = {**raw_extra, **(task_schema.notes or {})}
        order = task_schema.order if task_schema.order is not None else len(tasks)
        tasks.append(
            PlanTask(
                task_id=task_id,
                title=task_schema.title or task_id,
                kind=task_schema.kind or task_schema.content_type or "section",
                content_type=task_schema.content_type or task_schema.kind or "section",
                block_id=task_schema.layout_block_id or task_schema.block_id,
                order=int(order),
                asset_path=task_schema.asset_path,
                notes=notes,
            )
        )
    tasks.sort(key=lambda t: t.order)
    return tasks


def load_consensus(path: Path) -> Dict[str, ConsensusBlock]:
    mapping: Dict[str, ConsensusBlock] = {}
    if not path or not path.exists():
        return mapping
    with path.open("r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                data = json.loads(line)
            except json.JSONDecodeError:
                raise ValueError(f"Consensus file {path} contains invalid JSON")
            try:
                parsed = ConsensusBlockSchema.parse_obj(data)
            except ValidationError as exc:
                raise ValueError(f"Consensus block validation failed: {exc}") from exc
            assets_field = data.get("assets") if isinstance(data, dict) else None
            assets: List[str] = []
            if isinstance(assets_field, list):
                for entry in assets_field:
                    if isinstance(entry, str) and entry.strip():
                        assets.append(entry.strip())
            mapping[parsed.block_id] = ConsensusBlock(
                block_id=parsed.block_id,
                text=parsed.text,
                block_type=parsed.block_type,
                page_index=parsed.page_index,
                flagged=parsed.flagged,
                ocr_outputs=parsed.ocr_outputs,
                assets=assets,
            )
    return mapping


# ----------------------------------------------------------------------
# Main CLI
# ----------------------------------------------------------------------

def assemble(args: argparse.Namespace) -> Path:
    log_info(
        "Starting tex assembly",
        plan=str(args.plan),
        snippets_dir=str(args.snippets_dir),
        aggregate=args.aggregate,
    )
    plan = load_plan(args.plan)
    tasks = parse_tasks(plan)
    consensus = load_consensus(args.consensus) if args.consensus else {}
    blueprint: LayoutBlueprintSchema | Dict[str, Any] | None = None
    if args.layout_plan and args.layout_plan.exists():
        try:
            payload = json.loads(args.layout_plan.read_text(encoding="utf-8"))
        except json.JSONDecodeError as exc:  # pragma: no cover
            raise ValueError(f"Layout plan {args.layout_plan} is not valid JSON") from exc
        try:
            blueprint = LayoutBlueprintSchema.parse_obj(payload)
        except ValidationError as exc:
            raise ValueError(f"Layout plan {args.layout_plan} failed validation: {exc}") from exc
    llm = None
    if args.model_path:
        llm = LocalLLM(args.model_path, n_ctx=args.n_ctx, temperature=args.temperature, max_tokens=args.max_tokens)
    assembler = TexAssembler(llm=llm, blueprint=blueprint)
    snippets_dir = args.snippets_dir
    snippets_dir.mkdir(parents=True, exist_ok=True)

    doc_class_hint = plan.doc_class_hint or {}
    doc_class = plan.doc_class or doc_class_hint.get("candidate", "lix_article")
    frontmatter = plan.frontmatter
    golden_dir = args.golden_dir or (args.plan.parent / "golden_snippets")

    snippet_store: Dict[str, str] = {}
    meta_store: Dict[str, Dict[str, Any]] = {}

    for task in tasks:
        if task.task_id in {"PREAMBLE", "TITLE"}:
            continue
        block = consensus.get(task.block_id) if task.block_id else None
        snippet = _load_golden_snippet(golden_dir, task.task_id)
        if snippet is None:
            snippet = assembler.section_snippet(task, block)
        snippet_store[task.task_id] = snippet
        meta_store[task.task_id] = {
            "task_id": task.task_id,
            "capabilities": capabilities_from_text(snippet),
            "block_id": task.block_id,
            "auto_flagged": bool(block.flagged) if block else False,
        }

    content_flags = dict(assembler.layout_flags)
    content_flags.update(plan.content_flags)
    packages = determine_packages(content_flags, snippet_store.values())

    preamble_path = snippets_dir / "PREAMBLE.tex"
    preamble_path.write_text(assembler.preamble_snippet(doc_class, packages), encoding="utf-8")

    title_path = snippets_dir / "TITLE.tex"
    title_path.write_text(assembler.title_snippet(frontmatter), encoding="utf-8")

    for task in tasks:
        if task.task_id in {"PREAMBLE", "TITLE"}:
            continue
        snippet = snippet_store[task.task_id]
        snippet_path = snippets_dir / f"{task.task_id}.tex"
        snippet_path.write_text(snippet, encoding="utf-8")
        meta_path = snippet_path.with_suffix(".meta.json")
        meta_path.write_text(json.dumps(meta_store[task.task_id], indent=2), encoding="utf-8")

    if args.aggregate:
        run_aggregator(args.plan, snippets_dir, args.build_dir)

    log_info("Completed tex assembly", snippets_dir=str(snippets_dir))
    return snippets_dir


def run_aggregator(plan_path: Path, snippets_dir: Path, build_dir: Optional[Path]) -> None:
    build_root = build_dir or plan_path.parent
    build_root.mkdir(parents=True, exist_ok=True)
    aggregator = Path(__file__).resolve().parents[2] / "scripts" / "aggregator.py"
    log_info("Invoking aggregator", plan=str(plan_path), snippets=str(snippets_dir), build=str(build_root))
    cmd = [
        sys.executable,
        str(aggregator),
        "--plan",
        str(plan_path),
        "--snippets",
        str(snippets_dir),
        "--out",
        str(build_root),
    ]
    subprocess.run(cmd, check=True)


def build_arg_parser() -> argparse.ArgumentParser:
    ap = argparse.ArgumentParser(description="Step 3: Generate LaTeX snippets and optional assembly")
    ap.add_argument("--plan", type=Path, required=True, help="plan.json from planner")
    ap.add_argument("--consensus", type=Path, default=None, help="blocks_refined.jsonl from judge")
    ap.add_argument("--layout-plan", type=Path, default=None, help="layout_plan.json from Step 0")
    ap.add_argument("--snippets-dir", type=Path, default=Path("build/snippets"), help="Output directory for snippets")
    ap.add_argument("--golden-dir", type=Path, default=None, help="Directory containing golden snippets from judge")
    ap.add_argument("--model-path", type=Path, default=None, help="Optional GGUF model for preamble+sections")
    ap.add_argument("--n-ctx", type=int, default=8192)
    ap.add_argument("--temperature", type=float, default=0.2)
    ap.add_argument("--max-tokens", type=int, default=900)
    ap.add_argument("--aggregate", action="store_true", help="Run aggregator after generating snippets")
    ap.add_argument("--build-dir", type=Path, default=None, help="Destination build dir when --aggregate is set")
    ap.add_argument("--verbose", action="store_true", help="Enable debug logging")
    return ap


def main(argv: Optional[Sequence[str]] = None) -> int:
    ap = build_arg_parser()
    args = ap.parse_args(argv)
    configure_logging(verbose=args.verbose)
    assemble(args)
    return 0


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
