from __future__ import annotations

import argparse
import json
import re
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Iterable, List, Optional, Sequence

from .synth_shared import capabilities_from_text, slugify

try:  # optional llama backend for local coder models
    from .model_backends import LlamaCppBackend, LlamaCppConfig
except Exception:  # pragma: no cover - llama backend might be unavailable
    LlamaCppBackend = None  # type: ignore
    LlamaCppConfig = None  # type: ignore

_RE_WHITESPACE = re.compile(r"\s+")
_ESCAPE_MAP = str.maketrans({
    "\\": r"\\textbackslash{}",
    "{": r"\{",
    "}": r"\}",
    "%": r"\%",
    "#": r"\#",
    "&": r"\&",
    "$": r"\$",
    "_": r"\_",
})


@dataclass
class PlanTask:
    task_id: str
    title: str
    kind: str
    content_type: str
    block_id: Optional[str]
    order: int
    asset_path: Optional[str]
    notes: Dict[str, Any]


@dataclass
class ConsensusBlock:
    block_id: str
    text: str
    block_type: str
    page_index: int
    flagged: bool
    ocr_outputs: Dict[str, str]


class LocalLLM:
    def __init__(self, model_path: Path, *, n_ctx: int = 8192, temperature: float = 0.2, max_tokens: int = 600):
        if LlamaCppBackend is None or LlamaCppConfig is None:  # pragma: no cover - runtime guard
            raise RuntimeError("llama-cpp-python is not installed; cannot use --model-path")
        cfg = LlamaCppConfig(model_path=model_path, n_ctx=n_ctx, n_batch=512, seed=1337)
        self.backend = LlamaCppBackend(cfg)
        self.temperature = temperature
        self.max_tokens = max_tokens

    def generate(self, prompt: str) -> str:
        return self.backend.generate(
            prompt,
            max_tokens=self.max_tokens,
            temperature=self.temperature,
            top_p=0.9,
            top_k=40,
            repeat_penalty=1.05,
            stop=("```", "\n\n#", "\n\nTask"),
        ).strip()


class TexAssembler:
    def __init__(
        self,
        *,
        llm: Optional[LocalLLM],
        blueprint: Dict[str, Any] | None = None,
    ) -> None:
        self.llm = llm
        self.blueprint = blueprint or {}

    # ------------------------------------------------------------------
    # Public API
    # ------------------------------------------------------------------
    def preamble_snippet(self, doc_class: str, packages: Sequence[str]) -> str:
        blueprint_note = self._blueprint_summary()
        if self.llm:
            prompt = self._preamble_prompt(doc_class, blueprint_note)
            generated = self.llm.generate(prompt)
            cleaned = self._extract_latex(generated)
            if cleaned:
                return self._inject_packages(cleaned, packages)
        return self._fallback_preamble(doc_class, blueprint_note, packages)

    def title_snippet(self, frontmatter: Dict[str, Any]) -> str:
        title = escape_tex(frontmatter.get("title", "Untitled Document"))
        author = escape_tex(frontmatter.get("author", "Generated by LaTeXify"))
        course = frontmatter.get("course")
        if course:
            author = f"{author} \\textit{{({escape_tex(course)})}}"
        date = frontmatter.get("date", r"\today")
        return "\n".join([
            f"\\title{{{title}}}",
            f"\\author{{{author}}}",
            f"\\date{{{date}}}",
            r"\maketitle",
            "",
        ])

    def section_snippet(self, task: PlanTask, block: Optional[ConsensusBlock]) -> str:
        context = self._build_section_context(task, block)
        if self.llm:
            prompt = self._section_prompt(task, block, context)
            completion = self.llm.generate(prompt)
            cleaned = self._extract_latex(completion)
            if cleaned:
                return cleaned if cleaned.endswith("\n") else cleaned + "\n"
        return self._fallback_section(task, block, context)

    # ------------------------------------------------------------------
    # Prompt helpers
    # ------------------------------------------------------------------
    def _preamble_prompt(self, doc_class: str, blueprint_note: str) -> str:
        guidelines = blueprint_note or "Follow best practices for academic textbooks."
        return (
            r"You are a meticulous LaTeX engineer. Emit ONLY a preamble with \documentclass and required packages.\n"
            "Constraints:\n"
            f"- Document class: {doc_class}.\n"
            "- Include packages only if justified.\n"
            "- End with \\begin{document}.\n"
            f"Layout guidance: {guidelines}\n"
        )

    def _section_prompt(self, task: PlanTask, block: Optional[ConsensusBlock], context: Dict[str, str]) -> str:
        title = task.title or task.task_id
        blueprint_detail = self._blueprint_detail_for(title)
        block_text = context.get("source_text", "")
        hints = context.get("hints", "")
        return (
            "You are an expert LaTeX synthesizer. Convert the provided OCR text into polished LaTeX.\n"
            "Rules:\n"
            "- Output ONLY LaTeX for the section body (no preamble).\n"
            "- Use semantic structures (sections, figure, table, equation).\n"
            "- Prefer amsmath + booktabs conventions.\n"
            f"Section: {title}. Kind={task.kind} ContentType={task.content_type}.\n"
            f"Blueprint hints: {blueprint_detail}.\n"
            f"Layout guidance: {hints}.\n"
            "OCR snippet:\n" + block_text + "\nEnd of text."
        )

    # ------------------------------------------------------------------
    # Fallback renderers
    # ------------------------------------------------------------------
    def _fallback_preamble(self, doc_class: str, blueprint_note: str, packages: Sequence[str]) -> str:
        lines = [f"\\documentclass{{{doc_class or 'lix_textbook'}}}"]
        defaults = [
            "\\usepackage{microtype}",
            "\\usepackage{geometry}",
            "\\usepackage{hyperref}",
        ]
        pkg_lines = _unique(defaults + list(packages))
        lines.extend(pkg_lines)
        lines.append(r"\geometry{margin=1in}")
        lines.append(r"\hypersetup{hidelinks}")
        if blueprint_note:
            lines.append(f"% Layout: {blueprint_note}")
        lines.append(r"\begin{document}")
        return "\n".join(lines) + "\n"

    def _fallback_section(self, task: PlanTask, block: Optional[ConsensusBlock], context: Dict[str, str]) -> str:
        label = slugify(task.task_id or task.title)
        title = escape_tex(task.title or task.task_id)
        section_head = self._section_command(task)
        if block and block.block_type.lower().startswith("figure"):
            return self._figure_snippet(task, block, title, label)
        if block and "table" in block.block_type.lower():
            return self._table_snippet(task, block, context, title, label)
        if block and "math" in block.block_type.lower():
            return self._math_snippet(block, title, label)
        body = text_to_paragraphs(context.get("source_text", "")) or "% TODO: add content"
        return "\n".join([
            f"{section_head}{{{title}}}",
            f"\\label{{sec:{label}}}",
            body,
            "",
        ])

    def _figure_snippet(self, task: PlanTask, block: ConsensusBlock, title: str, label: str) -> str:
        asset = task.asset_path or "assets/figure-placeholder.pdf"
        return "\n".join([
            "\\begin{figure}[ht]",
            "  \\centering",
            f"  \\includegraphics[width=0.85\\linewidth]{{{asset}}}",
            f"  \\caption{{{title}}}",
            f"  \\label{{fig:{label}}}",
            "\\end{figure}",
            "",
        ])

    def _table_snippet(self, task: PlanTask, block: ConsensusBlock, context: Dict[str, str], title: str, label: str) -> str:
        rows = parse_table_rows(context.get("source_text", block.text))
        if not rows:
            return "% TODO: add table content\n"
        width = max(len(r) for r in rows)
        fmt = " ".join(["l"] * width)
        header = rows[0]
        body = rows[1:] or [[""] * width]
        lines = [
            "\\begin{table}[ht]",
            "  \\centering",
            f"  \\caption{{{title}}}",
            f"  \\label{{tab:{label}}}",
            f"  \\begin{{tabular}}{{{fmt}}}",
            "    \\toprule",
            "    " + " & ".join(header) + r" \\",
            "    \\midrule",
        ]
        for row in body:
            padded = row + [""] * (width - len(row))
            lines.append("    " + " & ".join(escape_tex(cell) for cell in padded) + r" \\")
        lines += [
            "    \\bottomrule",
            "  \\end{tabular}",
            "\\end{table}",
            "",
        ]
        return "\n".join(lines)

    def _math_snippet(self, block: ConsensusBlock, title: str, label: str) -> str:
        math_text = block.text.strip()
        if not math_text.startswith("\\") and not math_text.startswith("$"):
            math_text = "$" + math_text + "$"
        return "\n".join([
            f"% {title}",
            math_text,
            f"% label: eq:{label}",
            "",
        ])

    # ------------------------------------------------------------------
    # Utility helpers
    # ------------------------------------------------------------------
    def _blueprint_summary(self) -> str:
        layout = self.blueprint.get("plan", {}).get("page_layout") if isinstance(self.blueprint.get("plan"), dict) else None
        if not isinstance(layout, dict):
            layout = self.blueprint.get("page_layout", {}) if isinstance(self.blueprint, dict) else {}
        columns = layout.get("columns") if isinstance(layout, dict) else None
        title_area = layout.get("title_area") if isinstance(layout, dict) else None
        if columns or title_area:
            return f"columns={columns or 'single'}, title_area={title_area or 'top'}"
        return ""

    def _blueprint_detail_for(self, title: str) -> str:
        if not isinstance(self.blueprint, dict):
            return ""
        sections = self.blueprint.get("sections") or self.blueprint.get("plan", {}).get("sections")
        if not isinstance(sections, list):
            return ""
        for section in sections:
            if not isinstance(section, dict):
                continue
            if section.get("title") and section.get("title").lower() in title.lower():
                return section.get("layout", "")
        return ""

    def _section_command(self, task: PlanTask) -> str:
        kind = (task.kind or task.content_type or "body").lower()
        if "subsection" in kind:
            return "\\subsection"
        if "chapter" in kind:
            return "\\chapter"
        if "appendix" in kind:
            return "\\section"
        return "\\section"

    def _build_section_context(self, task: PlanTask, block: Optional[ConsensusBlock]) -> Dict[str, str]:
        ctx: Dict[str, str] = {}
        if block:
            ctx["source_text"] = block.text or block.ocr_outputs.get(task.notes.get("backend", ""), "") if task.notes else block.text
            ctx["hints"] = f"block_type={block.block_type}, page_index={block.page_index}"
        else:
            ctx["source_text"] = task.notes.get("placeholder", "") if task.notes else ""
            ctx["hints"] = "no block data"
        return ctx

    def _extract_latex(self, completion: str) -> str:
        text = completion.strip()
        if not text:
            return ""
        fence_idx = text.find("\n```")
        if fence_idx != -1:
            text = text[:fence_idx].strip()
        return text

    def _inject_packages(self, preamble: str, packages: Sequence[str]) -> str:
        if not packages:
            return preamble if preamble.endswith("\n") else preamble + "\n"
        lines = preamble.splitlines()
        idx = 1 if lines else 0
        new_lines = lines[:idx] + list(_unique(packages)) + lines[idx:]
        result = "\n".join(new_lines)
        return result if result.endswith("\n") else result + "\n"


# ----------------------------------------------------------------------
# Parsing helpers
# ----------------------------------------------------------------------

def escape_tex(value: str) -> str:
    return value.translate(_ESCAPE_MAP)


def text_to_paragraphs(text: str) -> str:
    chunks = [segment.strip() for segment in re.split(r"\n\s*\n", text or "") if segment.strip()]
    if not chunks:
        return ""
    return "\n\n".join(escape_tex(chunk) for chunk in chunks) + "\n"


def parse_table_rows(text: str) -> List[List[str]]:
    rows: List[List[str]] = []
    for line in (text or "").splitlines():
        raw = line.strip().strip("|")
        if not raw:
            continue
        if "|" in raw:
            cells = [cell.strip() for cell in raw.split("|")]
        else:
            cells = [cell.strip() for cell in re.split(r"\s{2,}", raw) if cell.strip()]
        if cells:
            rows.append([escape_tex(c) for c in cells])
    return rows


def determine_packages(flags: Dict[str, bool], snippets: Iterable[str]) -> List[str]:
    packages: List[str] = []
    if flags.get("has_math"):
        packages.extend(["\\usepackage{amsmath}", "\\usepackage{amssymb}"])
    if flags.get("has_tables"):
        packages.extend(["\\usepackage{booktabs}", "\\usepackage{caption}"])
    if flags.get("has_figures"):
        packages.append("\\usepackage{graphicx}")
    if flags.get("has_code"):
        packages.append("\\usepackage{listings}")
    if flags.get("has_chem"):
        packages.append("\\usepackage[version=4]{mhchem}")
    if flags.get("has_math") or flags.get("has_chem"):
        packages.append("\\usepackage{siunitx}")
    if flags.get("two_column"):
        packages.append("\\usepackage{multicol}")
    text_blob = "\n".join(snippets).lower()
    if "\\includegraphics" in text_blob and "\\usepackage{graphicx}" not in packages:
        packages.append("\\usepackage{graphicx}")
    if "\\ce{" in text_blob and not any("mhchem" in pkg for pkg in packages):
        packages.append("\\usepackage[version=4]{mhchem}")
    return _unique(packages)


def _load_golden_snippet(golden_dir: Optional[Path], task_id: str) -> Optional[str]:
    if not golden_dir or not Path(golden_dir).exists():
        return None
    candidate = Path(golden_dir) / f"{task_id}.tex"
    if candidate.exists():
        return candidate.read_text(encoding="utf-8")
    return None


def _inject_packages(preamble: str, packages: Sequence[str]) -> str:
    lines = preamble.splitlines()
    pkg_lines = [line for line in packages if line.strip()]
    if not pkg_lines:
        return preamble if preamble.endswith("\n") else preamble + "\n"
    insertion_idx = 1 if lines else 0
    new_lines = lines[:insertion_idx] + list(pkg_lines) + lines[insertion_idx:]
    result = "\n".join(new_lines)
    return result if result.endswith("\n") else result + "\n"


def _unique(values: Iterable[str]) -> List[str]:
    seen = set()
    ordered: List[str] = []
    for value in values:
        val = value.strip()
        if not val or val in seen:
            continue
        seen.add(val)
        ordered.append(val)
    return ordered


def load_plan(path: Path) -> Dict[str, Any]:
    return json.loads(path.read_text(encoding="utf-8"))


def parse_tasks(plan: Dict[str, Any]) -> List[PlanTask]:
    tasks: List[PlanTask] = []
    for task in plan.get("tasks", []):
        if not isinstance(task, dict):
            continue
        task_id = str(task.get("id") or task.get("task_id") or "")
        if not task_id:
            continue
        tasks.append(
            PlanTask(
                task_id=task_id,
                title=task.get("title") or task.get("name") or task_id,
                kind=task.get("kind") or task.get("type") or "section",
                content_type=task.get("content_type") or task.get("type") or "section",
                block_id=task.get("layout_block_id") or task.get("block_id"),
                order=int(task.get("order", len(tasks))),
                asset_path=task.get("asset_path"),
                notes={k: v for k, v in task.items() if k not in {"id", "title", "kind", "content_type", "layout_block_id", "block_id", "order", "asset_path"}},
            )
        )
    tasks.sort(key=lambda t: t.order)
    return tasks


def load_consensus(path: Path) -> Dict[str, ConsensusBlock]:
    mapping: Dict[str, ConsensusBlock] = {}
    if not path or not path.exists():
        return mapping
    with path.open("r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            data = json.loads(line)
            block_id = data.get("block_id") or data.get("id")
            if not block_id:
                continue
            mapping[str(block_id)] = ConsensusBlock(
                block_id=str(block_id),
                text=data.get("text") or data.get("golden_text") or "",
                block_type=data.get("block_type") or "text",
                page_index=int(data.get("page_index") or 0),
                flagged=bool(data.get("flagged")),
                ocr_outputs=data.get("ocr_outputs") or {},
            )
    return mapping


# ----------------------------------------------------------------------
# Main CLI
# ----------------------------------------------------------------------

def assemble(args: argparse.Namespace) -> Path:
    plan = load_plan(args.plan)
    tasks = parse_tasks(plan)
    consensus = load_consensus(args.consensus) if args.consensus else {}
    blueprint = {}
    if args.layout_plan and args.layout_plan.exists():
        blueprint = json.loads(args.layout_plan.read_text(encoding="utf-8"))
    llm = None
    if args.model_path:
        llm = LocalLLM(args.model_path, n_ctx=args.n_ctx, temperature=args.temperature, max_tokens=args.max_tokens)
    assembler = TexAssembler(llm=llm, blueprint=blueprint)
    snippets_dir = args.snippets_dir
    snippets_dir.mkdir(parents=True, exist_ok=True)

    doc_class = plan.get("doc_class") or (plan.get("doc_class_hint") or {}).get("candidate", "lix_article")
    frontmatter = plan.get("frontmatter", {})
    golden_dir = args.golden_dir or (args.plan.parent / "golden_snippets")

    snippet_store: Dict[str, str] = {}
    meta_store: Dict[str, Dict[str, Any]] = {}

    for task in tasks:
        if task.task_id in {"PREAMBLE", "TITLE"}:
            continue
        block = consensus.get(task.block_id) if task.block_id else None
        snippet = _load_golden_snippet(golden_dir, task.task_id)
        if snippet is None:
            snippet = assembler.section_snippet(task, block)
        snippet_store[task.task_id] = snippet
        meta_store[task.task_id] = {
            "task_id": task.task_id,
            "capabilities": capabilities_from_text(snippet),
            "block_id": task.block_id,
            "auto_flagged": bool(block.flagged) if block else False,
        }

    packages = determine_packages(plan.get("content_flags") or {}, snippet_store.values())

    preamble_path = snippets_dir / "PREAMBLE.tex"
    preamble_path.write_text(assembler.preamble_snippet(doc_class, packages), encoding="utf-8")

    title_path = snippets_dir / "TITLE.tex"
    title_path.write_text(assembler.title_snippet(frontmatter), encoding="utf-8")

    for task in tasks:
        if task.task_id in {"PREAMBLE", "TITLE"}:
            continue
        snippet = snippet_store[task.task_id]
        snippet_path = snippets_dir / f"{task.task_id}.tex"
        snippet_path.write_text(snippet, encoding="utf-8")
        meta_path = snippet_path.with_suffix(".meta.json")
        meta_path.write_text(json.dumps(meta_store[task.task_id], indent=2), encoding="utf-8")

    if args.aggregate:
        run_aggregator(args.plan, snippets_dir, args.build_dir)

    return snippets_dir


def run_aggregator(plan_path: Path, snippets_dir: Path, build_dir: Optional[Path]) -> None:
    build_root = build_dir or plan_path.parent
    build_root.mkdir(parents=True, exist_ok=True)
    aggregator = Path(__file__).resolve().parents[2] / "scripts" / "aggregator.py"
    cmd = [
        sys.executable,
        str(aggregator),
        "--plan",
        str(plan_path),
        "--snippets",
        str(snippets_dir),
        "--out",
        str(build_root),
    ]
    subprocess.run(cmd, check=True)


def build_arg_parser() -> argparse.ArgumentParser:
    ap = argparse.ArgumentParser(description="Step 3: Generate LaTeX snippets and optional assembly")
    ap.add_argument("--plan", type=Path, required=True, help="plan.json from planner")
    ap.add_argument("--consensus", type=Path, default=None, help="blocks_refined.jsonl from judge")
    ap.add_argument("--layout-plan", type=Path, default=None, help="layout_plan.json from Step 0")
    ap.add_argument("--snippets-dir", type=Path, default=Path("build/snippets"), help="Output directory for snippets")
    ap.add_argument("--golden-dir", type=Path, default=None, help="Directory containing golden snippets from judge")
    ap.add_argument("--model-path", type=Path, default=None, help="Optional GGUF model for preamble+sections")
    ap.add_argument("--n-ctx", type=int, default=8192)
    ap.add_argument("--temperature", type=float, default=0.2)
    ap.add_argument("--max-tokens", type=int, default=900)
    ap.add_argument("--aggregate", action="store_true", help="Run aggregator after generating snippets")
    ap.add_argument("--build-dir", type=Path, default=None, help="Destination build dir when --aggregate is set")
    return ap


def main(argv: Optional[Sequence[str]] = None) -> int:
    ap = build_arg_parser()
    args = ap.parse_args(argv)
    assemble(args)
    return 0


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
