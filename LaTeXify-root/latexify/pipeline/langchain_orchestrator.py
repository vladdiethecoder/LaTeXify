from __future__ import annotations

import argparse
import json
import shutil
import time
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Sequence

from latexify.ingestion.ingest_pdf import ingest_pdf
from . import layout_planner
from .judge_model import run_judge
from .tex_assembler import assemble as assemble_tex
from .qa_validator import run_preflight as run_qa_preflight

try:  # optional LangChain
    from langchain_core.runnables import RunnableLambda, RunnableSequence  # type: ignore
except Exception:  # pragma: no cover
    RunnableLambda = None  # type: ignore
    RunnableSequence = None  # type: ignore


@dataclass
class PipelineConfig:
    pdf: Path
    title: str = "Untitled Document"
    author: str = "Generated by LaTeXify"
    course: str = ""
    doc_class: str = "lix_textbook"
    run_root: Path = Path("dev/runs")
    build_dir: Path = Path("build")
    prefer_remote_layout: bool = False
    layout_text: Optional[str] = None
    layout_images: Sequence[Path] = field(default_factory=tuple)
    pages_override: Optional[List[str]] = None
    aggregate: bool = True
    qa_enabled: bool = True
    qa_attempt_compile: bool = False
    qa_max_passes: int = 1


@dataclass
class PipelineState:
    config: PipelineConfig
    run_dir: Optional[Path] = None
    layout_plan: Optional[Path] = None
    consensus_path: Optional[Path] = None
    plan_path: Optional[Path] = None
    snippets_dir: Optional[Path] = None
    qa_report: Optional[Path] = None


# ---------------------------------------------------------------------------
# Steps
# ---------------------------------------------------------------------------

def step_setup(state: PipelineState) -> PipelineState:
    cfg = state.config
    run_dir = cfg.run_root / time.strftime("%Y%m%d_%H%M%S")
    run_dir.mkdir(parents=True, exist_ok=True)
    if cfg.pdf.exists():
        shutil.copy2(cfg.pdf, run_dir / cfg.pdf.name)
    state.run_dir = run_dir
    cfg.build_dir.mkdir(parents=True, exist_ok=True)
    return state


def step_layout(state: PipelineState) -> PipelineState:
    cfg = state.config
    planner = layout_planner.LayoutPlanner(
        layout_planner.LayoutPlannerConfig(prefer_remote=cfg.prefer_remote_layout)
    )
    text = cfg.layout_text or _read_pdf_excerpt(cfg.pdf, cfg.pages_override)
    blueprint = planner.generate(text, cfg.layout_images)
    out_path = cfg.build_dir / "layout_plan.json"
    out_path.write_text(json.dumps(blueprint.to_json(), indent=2), encoding="utf-8")
    state.layout_plan = out_path
    return state


def step_ingest(state: PipelineState) -> PipelineState:
    if not state.run_dir:
        raise RuntimeError("Run dir missing")
    cfg = state.config
    ingest_pdf(
        cfg.pdf,
        state.run_dir,
        assets_dir=cfg.build_dir / "assets",
        pages_override=cfg.pages_override,
    )
    return state


def step_judge(state: PipelineState) -> PipelineState:
    if not state.run_dir:
        raise RuntimeError("Run dir missing")
    state.consensus_path = run_judge(state.run_dir)
    return state


def step_plan(state: PipelineState) -> PipelineState:
    if not state.consensus_path:
        raise RuntimeError("Consensus missing")
    cfg = state.config
    plan = _auto_plan_from_consensus(state.consensus_path, cfg)
    plan_path = cfg.build_dir / "plan.auto.json"
    plan_path.write_text(json.dumps(plan, indent=2), encoding="utf-8")
    state.plan_path = plan_path
    return state


def step_tex(state: PipelineState) -> PipelineState:
    if not state.plan_path or not state.consensus_path:
        raise RuntimeError("Plan/consensus missing")
    cfg = state.config
    args = argparse.Namespace(
        plan=state.plan_path,
        consensus=state.consensus_path,
        layout_plan=state.layout_plan,
        snippets_dir=cfg.build_dir / "snippets",
        model_path=None,
        n_ctx=8192,
        temperature=0.2,
        max_tokens=900,
        aggregate=cfg.aggregate,
        build_dir=cfg.build_dir,
        golden_dir=None,
    )
    state.snippets_dir = assemble_tex(args)
    return state


def step_qa(state: PipelineState) -> PipelineState:
    cfg = state.config
    if not cfg.qa_enabled:
        return state
    if not state.plan_path or not state.snippets_dir:
        return state
    qa_path = run_qa_preflight(
        state.plan_path,
        state.snippets_dir,
        build_dir=cfg.build_dir,
        attempt_compile=cfg.qa_attempt_compile,
        max_passes=cfg.qa_max_passes,
        main_tex=(cfg.build_dir / "main.tex") if cfg.build_dir else None,
    )
    state.qa_report = qa_path
    return state


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

def _read_pdf_excerpt(pdf: Path, pages_override: Optional[List[str]]) -> str:
    if pages_override:
        return "\n\n".join(pages_override[:2])
    try:
        from pypdf import PdfReader
    except Exception:
        return ""
    if not pdf.exists():
        return ""
    try:
        reader = PdfReader(str(pdf))
    except Exception:
        return ""
    texts = []
    for page in reader.pages[:2]:
        texts.append(page.extract_text() or "")
    return "\n\n".join(texts)


def _auto_plan_from_consensus(consensus_path: Path, cfg: PipelineConfig) -> Dict[str, Any]:
    tasks: List[Dict[str, Any]] = [
        {"id": "PREAMBLE", "kind": "preamble", "content_type": "frontmatter", "order": 0},
        {"id": "TITLE", "kind": "title", "content_type": "frontmatter", "order": 1},
    ]
    with consensus_path.open("r", encoding="utf-8") as f:
        for idx, line in enumerate(f, start=2):
            data = json.loads(line)
            block_id = str(data.get("block_id") or f"BLOCK-{idx}")
            block_type = str(data.get("block_type") or "section")
            tasks.append(
                {
                    "id": block_id,
                    "title": data.get("title") or block_id.replace("_", " "),
                    "kind": _map_block_kind(block_type),
                    "content_type": block_type,
                    "order": idx,
                    "layout_block_id": block_id,
                }
            )
    return {
        "doc_class": cfg.doc_class,
        "frontmatter": {"title": cfg.title, "author": cfg.author, "course": cfg.course, "date": r"\today"},
        "tasks": tasks,
    }


def _map_block_kind(block_type: str) -> str:
    block = block_type.lower()
    if "figure" in block:
        return "figure"
    if "table" in block:
        return "table"
    if "math" in block or "equation" in block:
        return "math"
    return "section"


def run_pipeline(config: PipelineConfig, *, use_langchain: bool | None = None) -> PipelineState:
    state = PipelineState(config=config)
    steps: List[Callable[[PipelineState], PipelineState]] = [
        step_setup,
        step_layout,
        step_ingest,
        step_judge,
        step_plan,
        step_tex,
    ]
    if config.qa_enabled:
        steps.append(step_qa)
    use_sequence = use_langchain if use_langchain is not None else RunnableSequence is not None
    if use_sequence and RunnableSequence and RunnableLambda:
        chain = RunnableSequence(*[RunnableLambda(lambda s, fn=fn: fn(s)) for fn in steps])
        return chain.invoke(state)
    for fn in steps:
        state = fn(state)
    return state


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------

def build_arg_parser() -> argparse.ArgumentParser:
    ap = argparse.ArgumentParser(description="LangChain-powered LaTeXify orchestrator")
    ap.add_argument("--pdf", type=Path, required=True)
    ap.add_argument("--title", type=str, default="Untitled Document")
    ap.add_argument("--author", type=str, default="Generated by LaTeXify")
    ap.add_argument("--course", type=str, default="")
    ap.add_argument("--doc-class", type=str, default="lix_textbook")
    ap.add_argument("--run-root", type=Path, default=Path("dev/runs"))
    ap.add_argument("--build-dir", type=Path, default=Path("build"))
    ap.add_argument("--langchain", action="store_true")
    ap.add_argument("--no-langchain", action="store_true")
    ap.add_argument("--aggregate", action="store_true")
    ap.add_argument("--qa", action="store_true", help="Force QA preflight")
    ap.add_argument("--no-qa", action="store_true", help="Disable QA preflight")
    ap.add_argument("--qa-compile", action="store_true", help="Attempt latexmk compile during QA")
    ap.add_argument("--qa-max-passes", type=int, default=1, help="Maximum auto-fix passes per environment")
    return ap


def main(argv: Optional[Sequence[str]] = None) -> int:
    ap = build_arg_parser()
    args = ap.parse_args(argv)
    qa_enabled = not args.no_qa
    if args.qa:
        qa_enabled = True
    cfg = PipelineConfig(
        pdf=args.pdf,
        title=args.title,
        author=args.author,
        course=args.course,
        doc_class=args.doc_class,
        run_root=args.run_root,
        build_dir=args.build_dir,
        aggregate=args.aggregate,
        qa_enabled=qa_enabled,
        qa_attempt_compile=args.qa_compile,
        qa_max_passes=max(1, args.qa_max_passes),
    )
    use_chain = args.langchain
    if args.no_langchain:
        use_chain = False
    state = run_pipeline(cfg, use_langchain=use_chain)
    summary = {
        "run_dir": str(state.run_dir) if state.run_dir else None,
        "layout_plan": str(state.layout_plan) if state.layout_plan else None,
        "consensus": str(state.consensus_path) if state.consensus_path else None,
        "plan": str(state.plan_path) if state.plan_path else None,
        "snippets": str(state.snippets_dir) if state.snippets_dir else None,
        "qa_report": str(state.qa_report) if state.qa_report else None,
    }
    print(json.dumps(summary, indent=2))
    return 0


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
