#!/usr/bin/env python3
"""
Minimal deterministic planner that emits plan.json.

Usage (writes to build/plan.json by default via pipeline.py):
  python scripts/planner_scaffold.py \
    --out build/plan.json \
    --doc-class lix_textbook \
    --title "Basic Skills Review" \
    --author "Student X" \
    --course "MATH 101" \
    --date "\\today" \
    --questions Q1a,Q1b,Q2

Python: 3.11+
"""
from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Dict, List, Sequence


def _split_list(csv: str | None) -> List[str]:
    if not csv:
        return []
    return [s.strip() for s in csv.split(",") if s.strip()]


def _emit_plan(
    doc_class: str,
    *,
    title: str = "Untitled Document",
    author: str = "Generated by LaTeXify",
    course: str = "",
    date: str = r"\today",
    questions: Sequence[str] | None = None,
    layout_types: Dict[str, str] | None = None,
) -> dict:

    tasks = [
        {"id": "PREAMBLE", "type": "preamble", "order": 0, "content_type": "frontmatter"},
        {"id": "TITLE", "type": "titlepage", "order": 1, "content_type": "frontmatter"},
    ]

    for i, q in enumerate(questions or (), start=2):
        entry = {"id": q, "type": "question", "title": q.replace("_", " "), "order": i}
        if layout_types and q in layout_types:
            entry["content_type"] = layout_types[q]
        tasks.append(entry)

    plan = {
        "doc_class": doc_class,
        "frontmatter": {
            "title": title,
            "author": author,
            "course": course,
            "date": date,
        },
        "tasks": tasks,
    }
    return plan

def validate_plan(plan: dict) -> None:
    seen_ids: set[str] = set()
    previous_order: int | None = None

    for task in plan.get("tasks", []):
        task_id = task.get("id")
        if task_id in seen_ids:
            raise SystemExit(f"Duplicate task id detected: {task_id}")
        seen_ids.add(task_id)

        order = task.get("order")
        if previous_order is not None and order <= previous_order:
            raise SystemExit(
                "Task order must be strictly increasing: "
                f"{previous_order} -> {order} for task {task_id}"
            )
        previous_order = order


def _load_layout_types(path: Path | None) -> Dict[str, str]:
    if not path or not path.exists():
        return {}
    try:
        data = json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return {}

    mapping: Dict[str, str] = {}

    def _walk(obj):
        if isinstance(obj, dict):
            if "id" in obj and "type" in obj:
                mapping[str(obj["id"])] = str(obj["type"])
            for value in obj.values():
                _walk(value)
        elif isinstance(obj, list):
            for item in obj:
                _walk(item)

    _walk(data)
    return mapping


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--out", type=Path, required=True)
    ap.add_argument("--doc-class", default="lix_textbook")
    ap.add_argument("--title", default="Untitled Document")
    ap.add_argument("--author", default="Generated by LaTeXify")
    ap.add_argument("--course", default="")
    ap.add_argument("--date", default=r"\today")
    ap.add_argument("--questions", default="", help="CSV list, e.g. Q1a,Q1b,Q2")
    ap.add_argument("--layout-json", type=Path, help="Optional layout analysis JSON with block types")
    args = ap.parse_args()

    layout_types = _load_layout_types(args.layout_json)

    plan = _emit_plan(
        args.doc_class,
        title=args.title,
        author=args.author,
        course=args.course,
        date=args.date,
        questions=_split_list(args.questions),
        layout_types=layout_types,
    )

    validate_plan(plan)

    args.out.parent.mkdir(parents=True, exist_ok=True)
    args.out.write_text(json.dumps(plan, indent=2), encoding="utf-8")
    print(f"Wrote plan â†’ {args.out}")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
