#!/usr/bin/env python3
"""
Command-line entry point for the lightweight planner.

This script accepts a document class and a comma‑separated list of question
identifiers and produces a ``plan.json`` describing the tasks required to
construct a LaTeX document.  Optional inputs allow you to incorporate
layout analysis and asset manifest data.  The heavy lifting is delegated
to ``latexify.pipeline.planner_scaffold``; this wrapper simply handles
argument parsing and file I/O.

Example::

    python scripts/planner_scaffold.py \
      --out build/plan.json \
      --doc-class lix_textbook \
      --title "Basic Skills Review" \
      --author "Student X" \
      --course "MATH 101" \
      --questions Q1a,Q1b,Q2 \
      --layout-json build/layout.json \
      --asset-manifest build/assets.json
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path

from latexify.pipeline.planner_scaffold import (
    _emit_plan,
    _load_block_consensus,
    validate_plan,
    _load_layout_blocks,
    _load_asset_manifest,
    _split_list,
    TEXT_DISAGREEMENT_THRESHOLD,
    LATEX_DISAGREEMENT_THRESHOLD,
)


def _relativize_path(target: Path, base_dir: Path) -> str:
    try:
        return str(target.relative_to(base_dir))
    except ValueError:
        return str(target)


def main() -> int:
    ap = argparse.ArgumentParser(description="Emit a LaTeX document plan from questions and optional metadata")
    ap.add_argument("--out", type=Path, required=True, help="Destination file for the generated plan (JSON)")
    ap.add_argument("--doc-class", default="lix_textbook", help="Document class (default: lix_textbook)")
    ap.add_argument("--title", default="Untitled Document", help="Title for the document")
    ap.add_argument("--author", default="Generated by LaTeXify", help="Author name")
    ap.add_argument("--course", default="", help="Course identifier or description")
    ap.add_argument("--date", default=r"\today", help="Date to embed in the document (LaTeX accepted)")
    ap.add_argument("--questions", default="", help="Comma‑separated list of question identifiers, e.g. Q1a,Q1b,Q2")
    ap.add_argument(
        "--layout-json",
        type=Path,
        default=None,
        help="Path to optional layout analysis JSON or JSONL file",
    )
    ap.add_argument(
        "--asset-manifest",
        type=Path,
        default=None,
        help="Path to optional asset manifest JSON file",
    )
    ap.add_argument(
        "--block-consensus",
        type=Path,
        default=None,
        help="Optional blocks_refined.jsonl containing OCR consensus metadata",
    )
    ap.add_argument(
        "--consensus-out",
        type=Path,
        default=None,
        help="Optional path for the emitted consensus bundle (defaults beside plan)",
    )
    args = ap.parse_args()
    # Load optional metadata
    layout_blocks = _load_layout_blocks(args.layout_json)
    asset_lookup = _load_asset_manifest(args.asset_manifest)
    block_consensus = _load_block_consensus(args.block_consensus)
    plan = _emit_plan(
        args.doc_class,
        title=args.title,
        author=args.author,
        course=args.course,
        date=args.date,
        questions=_split_list(args.questions),
        layout_blocks=layout_blocks,
        assets=asset_lookup,
        block_consensus=block_consensus,
    )
    if block_consensus:
        consensus_out = args.consensus_out or args.out.with_name("consensus.bundle.json")
        consensus_out.parent.mkdir(parents=True, exist_ok=True)
        payload = {
            "meta": {
                "source": str(args.block_consensus) if args.block_consensus else None,
                "agreement_threshold": TEXT_DISAGREEMENT_THRESHOLD,
                "latex_agreement_threshold": LATEX_DISAGREEMENT_THRESHOLD,
            },
            "blocks": {bid: bc.to_bundle_dict() for bid, bc in block_consensus.items()},
        }
        consensus_out.write_text(json.dumps(payload, indent=2), encoding="utf-8")
        bundle_info = {
            "path": _relativize_path(consensus_out, args.out.parent),
        }
        if args.block_consensus:
            bundle_info["source"] = str(args.block_consensus)
        plan["consensus_bundle"] = bundle_info
    # Validate the plan before writing
    validate_plan(plan)
    # Ensure output directory exists
    args.out.parent.mkdir(parents=True, exist_ok=True)
    args.out.write_text(json.dumps(plan, indent=2), encoding="utf-8")
    print(f"Wrote plan → {args.out}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())