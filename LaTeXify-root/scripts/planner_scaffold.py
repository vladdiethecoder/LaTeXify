#!/usr/bin/env python3
"""
Minimal deterministic planner that emits plan.json.

Usage (writes to build/plan.json by default via pipeline.py):
  python scripts/planner_scaffold.py \
    --out build/plan.json \
    --doc-class lix_textbook \
    --title "Basic Skills Review" \
    --author "Student X" \
    --course "MATH 101" \
    --date "\\today" \
    --questions Q1a,Q1b,Q2

Python: 3.11+
"""
from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Dict, List, Sequence


def _split_list(csv: str | None) -> List[str]:
    if not csv:
        return []
    return [s.strip() for s in csv.split(",") if s.strip()]


def _emit_plan(
    doc_class: str,
    *,
    title: str = "Untitled Document",
    author: str = "Generated by LaTeXify",
    course: str = "",
    date: str = r"\today",
    questions: Sequence[str] | None = None,
    layout_metadata: Dict[str, Dict[str, str]] | None = None,
) -> dict:

    layout_metadata = layout_metadata or {}
    tasks = [
        {"id": "PREAMBLE", "type": "preamble", "order": 0, "content_type": "frontmatter"},
        {"id": "TITLE", "type": "titlepage", "order": 1, "content_type": "frontmatter"},
    ]

    for i, q in enumerate(questions or (), start=2):
        entry = {"id": q, "type": "question", "title": q.replace("_", " "), "order": i}
        info = layout_metadata.get(q)
        if info:
            content_type = info.get("content_type")
            if content_type:
                entry["content_type"] = content_type
            asset_path = info.get("asset_path")
            if asset_path:
                entry["asset_path"] = asset_path
        tasks.append(entry)

    plan = {
        "doc_class": doc_class,
        "frontmatter": {
            "title": title,
            "author": author,
            "course": course,
            "date": date,
        },
        "tasks": tasks,
    }
    return plan

def validate_plan(plan: dict) -> None:
    seen_ids: set[str] = set()
    previous_order: int | None = None

    for task in plan.get("tasks", []):
        task_id = task.get("id")
        if task_id in seen_ids:
            raise SystemExit(f"Duplicate task id detected: {task_id}")
        seen_ids.add(task_id)

        order = task.get("order")
        if previous_order is not None and order <= previous_order:
            raise SystemExit(
                "Task order must be strictly increasing: "
                f"{previous_order} -> {order} for task {task_id}"
            )
        previous_order = order


def _load_layout_metadata(path: Path | None) -> Dict[str, Dict[str, str]]:
    if not path or not path.exists():
        return {}
    try:
        if path.suffix.lower() == ".jsonl":
            payload = [
                json.loads(line)
                for line in path.read_text(encoding="utf-8").splitlines()
                if line.strip()
            ]
        else:
            payload = json.loads(path.read_text(encoding="utf-8"))
    except Exception:
        return {}

    metadata: Dict[str, Dict[str, str]] = {}

    def _merge(entry_id: str, *, content_type: str | None, asset_path: str | None) -> None:
        info = metadata.setdefault(entry_id, {})
        if content_type and "content_type" not in info:
            info["content_type"] = content_type
        if asset_path and "asset_path" not in info:
            info["asset_path"] = asset_path

    def _walk(obj):
        if isinstance(obj, dict):
            entry_id = obj.get("id") or obj.get("task_id")
            content_type = obj.get("content_type") or obj.get("type")
            asset_path = (
                obj.get("asset_path")
                or obj.get("image_path")
                or obj.get("asset")
                or obj.get("path")
            )
            if entry_id is not None:
                ct = str(content_type) if content_type else None
                ap = str(asset_path) if isinstance(asset_path, str) and asset_path else None
                _merge(str(entry_id), content_type=ct, asset_path=ap)
            for value in obj.values():
                _walk(value)
        elif isinstance(obj, list):
            for item in obj:
                _walk(item)

    _walk(payload)
    return metadata


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--out", type=Path, required=True)
    ap.add_argument("--doc-class", default="lix_textbook")
    ap.add_argument("--title", default="Untitled Document")
    ap.add_argument("--author", default="Generated by LaTeXify")
    ap.add_argument("--course", default="")
    ap.add_argument("--date", default=r"\today")
    ap.add_argument("--questions", default="", help="CSV list, e.g. Q1a,Q1b,Q2")
    ap.add_argument("--layout-json", type=Path, help="Optional layout analysis JSON with block types")
    args = ap.parse_args()

    layout_metadata = _load_layout_metadata(args.layout_json)

    plan = _emit_plan(
        args.doc_class,
        title=args.title,
        author=args.author,
        course=args.course,
        date=args.date,
        questions=_split_list(args.questions),
        layout_metadata=layout_metadata,
    )

    validate_plan(plan)

    args.out.parent.mkdir(parents=True, exist_ok=True)
    args.out.write_text(json.dumps(plan, indent=2), encoding="utf-8")
    print(f"Wrote plan â†’ {args.out}")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
