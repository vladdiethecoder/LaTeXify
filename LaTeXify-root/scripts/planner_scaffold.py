#!/usr/bin/env python3
"""
Minimal deterministic planner that emits plan.json.

Usage (writes to build/plan.json by default via pipeline.py):
  python scripts/planner_scaffold.py \
    --out build/plan.json \
    --doc-class lix_textbook \
    --title "Basic Skills Review" \
    --author "Student X" \
    --course "MATH 101" \
    --date "\\today" \
    --questions Q1a,Q1b,Q2

Python: 3.11+
"""
from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import List, Sequence


    def _split_list(csv: str | None) -> List[str]:
        if not csv:
            return []
        return [s.strip() for s in csv.split(",") if s.strip()]

    def _emit_plan(
        doc_class: str,
        *,
        title: str = "Untitled Document",
        author: str = "Generated by LaTeXify",
        course: str = "",
        date: str = r"\today",
        questions: Sequence[str] | None = None,
    ) -> dict:

    tasks = [
        {"id": "PREAMBLE", "type": "preamble", "order": 0},
        {"id": "TITLE", "type": "titlepage", "order": 1},
    ]

    for i, q in enumerate(questions or (), start=2):
        tasks.append({"id": q, "type": "question", "title": q.replace("_", " "), "order": i})

    plan = {
        "doc_class": doc_class,
        "frontmatter": {
            "title": title,
            "author": author,
            "course": course,
            "date": date,
        },
        "tasks": tasks,
    }
    return plan

def validate_plan(plan: dict) -> None:
    seen_ids: set[str] = set()
    previous_order: int | None = None

    for task in plan.get("tasks", []):
        task_id = task.get("id")
        if task_id in seen_ids:
            raise SystemExit(f"Duplicate task id detected: {task_id}")
        seen_ids.add(task_id)

        order = task.get("order")
        if previous_order is not None and order <= previous_order:
            raise SystemExit(
                "Task order must be strictly increasing: "
                f"{previous_order} -> {order} for task {task_id}"
            )
        previous_order = order


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--out", type=Path, required=True)
    ap.add_argument("--doc-class", default="lix_textbook")
    ap.add_argument("--title", default="Untitled Document")
    ap.add_argument("--author", default="Generated by LaTeXify")
    ap.add_argument("--course", default="")
    ap.add_argument("--date", default=r"\today")
    ap.add_argument("--questions", default="", help="CSV list, e.g. Q1a,Q1b,Q2")
    args = ap.parse_args()

    plan = _emit_plan(
        args.doc_class,
        title=args.title,
        author=args.author,
        course=args.course,
        date=args.date,
        questions=_split_list(args.questions),
    )

    validate_plan(plan)

    args.out.parent.mkdir(parents=True, exist_ok=True)
    args.out.write_text(json.dumps(plan, indent=2), encoding="utf-8")
    print(f"Wrote plan â†’ {args.out}")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
